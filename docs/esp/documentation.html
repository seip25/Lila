<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="canonical" href="https://seip25.github.io/Lila/" />
    <title>Lila Framework - Python Web Framework</title>
    <meta name="google-site-verification" content="X_F63szaGUDmU8TZv_IJ0GvT79Cfncj5YqBJHTKp1t0" />
    <meta name="description"
        content="Lila is a minimalist Python framework based on Starlette and Pydantic, designed for simplicity, flexibility, and high performance.">
    <meta name="keywords" content="Python, Web Framework, API, Starlette, Pydantic, SQLAlchemy, JWT">
    <meta name="author" content="Lila Framework Team">

    <!-- Spanish Meta Tags -->
    <meta name="description" lang="es"
        content="Lila es un framework minimalista de Python basado en Starlette y Pydantic, diseñado para ser simple, flexible y de alto rendimiento.">
    <meta name="keywords" lang="es" content="Python, Framework Web, API, Starlette, Pydantic,  SQLAlchemy, JWT">

    <!-- Open Graph / Facebook -->
    <meta property="og:title" content="Lila Framework - Minimalist Python Web Framework">
    <meta property="og:description"
        content="Lila is a minimalist Python framework based on Starlette and Pydantic, designed for simplicity, flexibility, and high performance.">
    <meta property="og:image" content="https://seip25.github.io/Lila/img/lila.png">
    <meta property="og:url" content="https://seip25.github.io/Lila/">
    <meta property="og:type" content="website">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Lila Framework - Minimalist Python Web Framework">
    <meta name="twitter:description"
        content="Lila is a minimalist Python framework based on Starlette and Pydantic, designed for simplicity, flexibility, and high performance.">
    <meta name="twitter:image" content="https://seip25.github.io/Lila/img/lila.png">

    <!-- Multi-language support -->
    <meta name="language" content="en, es">
    <meta http-equiv="Content-Language" content="en, es">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="https://seip25.github.io/Lila/img/lila.png" alt="Lila Framework Logo">

    <!-- Stylesheets -->
    <link rel="stylesheet" href="../css/pico.min.css">
    <link rel="stylesheet" href="../css/atom-one-dark.min.css">
    <link rel="stylesheet" href="../css/index.css">
    <link rel="stylesheet" href="../css/doc.css">

    <!-- Highlight.js -->
    <script src="../js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <!-- Scripts -->
    <script src="../js/index.js"></script>

</head>

<body>
    <header class="container">
        <nav>
            <ul>
                <li>
                    <a href="index.html">
                        <h1 class="text-lila">Lila Framework</h1>
                    </a>
                </li>
            </ul>
            <ul>

                <li>
                    <details class="dropdown">
                        <summary>🌐</summary>
                        <ul dir="rtl">
                            <li><a href="documentation.html">Español</a></li>
                            <li><a href="../documentation.html">English</a></li>
                        </ul>
                    </details>
                </li>
            </ul>
        </nav>
    </header>
    <main class="container ">

        <div class="grid">
            <aside>
                <header>
                    <nav>

                        <ul>
                            <li><a href="#install-esp">Instalación</a></li>
                            <li><a href="#routes-esp">Rutas</a></li>
                            <li><a href="#static-esp">Static</a></li>
                            <li><a href="#templates-esp">Templates</a></li>
                            <li><a href="#react-seo">React</a></li>
                            <li><a href="#upload-esp">Upload de archivos</a></li>
                            <li><a href="#markdown-esp">Markdown/HTML</a></li>
                            <li><a href="#locales-esp">Internalización (Traducciones)</a></li>
                            <li><a href="#models-esp">Modelos</a></li>
                            <li><a href="#middlewares-esp">Middlewares</a></li>
                            <li><a href="#connections-esp">Connections</a></li>
                            <li><a href="#migrations-esp">Migraciones</a></li>
                            <li><a href="#rest_api_crud-esp">Generación sencilla de CRUD de API Rest</a></li>
                            <li><a href="#admin-panel-esp">Panel de Admin</a></li>
                            <li><a href="#minify-esp">Minificar archivos para producción</a></li>
                            <li><a href="#production-esp">Producción</a></li>
                            <!-- <li><a href="#helpers-esp">Helpers</a></li> -->
                        </ul>
                    </nav>
                </header>
            </aside>

            <div class="main">
                <div id="search">
                    <input type="search" name="search" id="searchBox" placeholder="Buscar..."
                        onkeyup="searchDocs(false,'esp')">
                    <ul id="searchResults"></ul>
                </div>

                <br />
                <div id="doc">

                    <div id="doc-esp">


                        <article id="install-esp">
                            <h2>Instalación</h2>
                            <div class="terminal">
                                <div class="terminal-encabezado">
                                    <span class="terminal-titulo">Instalación</span>
                                    <div class="terminal-controles">
                                        <div class="control cerrar"></div>
                                        <div class="control minimizar"></div>
                                        <div class="control maximizar"></div>
                                    </div>
                                </div>
                                <div class="terminal-contenido">
                                    <span class="comando">$ python -m venv venv # O python3 -m venv venv</span><br>
                                    <span class="comando">$ source venv/bin/activate # En Windows puedes usar
                                        `venv\Scripts\activate`</span><br>
                                    <span class="comando">$ pip install lila-framework</span><br>
                                    <span class="comando">$ lila-init</span><br>
                                    <span class="comando">$ python main.py #O python3 main.py</span><br>
                                    <span class="cursor"></span>
                                </div>
                            </div>
                        </article>

                        <article id="app-py-es">
                            <h2>Explicación de main.py</h2>
                            <h5>
                                Propósito: Configurar y arrancar la aplicación.
                                main.py es el punto de entrada principal donde se configura e inicializa la aplicación.

                            </h5>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Explicación de main.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from core.app import App
from app.routes.routes import routes
from app.routes.api import routes as api_routes
from core.middleware import Middleware
from app.config import PORT, HOST, DEBUG
from app.middlewares.defaults import (
    LoggingMiddleware,
    IPBlockingMiddleware,
    URLBlockingMiddleware,
    MaliciousExtensionMiddleware,
    SensitivePathMiddleware,
    ErrorHandlerMiddleware,
)
import itertools
import uvicorn
import asyncio

# English: Combining application and API routes into a single list.
# Español: Combinando las rutas de la aplicación y la API en una única lista.
all_routes = list(itertools.chain(routes, api_routes))

# English: Here we activate the admin panel with default settings.
# Español: Aquí activamos el panel de administrador con configuraciones predeterminadas.
# from app.routes.admin import Admin
# from app.models.user import User
# admin_routes=Admin(models=[User])
# all_routes = list(itertools.chain(routes, api_routes,admin_routes))
# English: Marker for the admin routes in main.py.
# Español: Marcador para las rutas de administrador en main.py.
# admin_marker

cors = None

# English: CORS usage example
# Español : Ejemplo de utilización de CORS
# cors={
#     "origin": ["*"],
#     "allow_credentials" : True,
#     "allow_methods":["*"],
#     "allow_headers": ["*"]
# }
# app = App(debug=True, routes=all_routes,cors=cors)

# English:necessary for cli command modify react cors for development
# Español:necesario para el comando cli modificar cors de react para desarrollo
# react_marker

middlewares = [
    Middleware(LoggingMiddleware),
    Middleware(IPBlockingMiddleware),
    Middleware(URLBlockingMiddleware),
    Middleware(MaliciousExtensionMiddleware),
    Middleware(SensitivePathMiddleware),
    Middleware(ErrorHandlerMiddleware),
]

# English: Initializing the application with debugging enabled and the combined routes.
# Español: Inicializando la aplicación con la depuración activada y las rutas combinadas.
app = App(debug=DEBUG, routes=all_routes, cors=cors, middleware=middlewares)

# English: To ensure SEO (bots, AI), caching, and HTML hydration, uncomment these lines.
# Adding {% include "react/cache/index.html" %} to <div id="root">
# Español :Para tener seo (bots,ia) ,cache y que react hidrate el html ,descomenta estas lineas.
# Agregadando en <div id="root"> ,  {% include "react/cache/index.html"  %}

# import subprocess
# import sys

# @app.on_event("startup")
# async def startup_event():
#     print("♻️ Prerender for react...")
#     url_with_port =f" http://{HOST}:{PORT}"
#     subprocess.Popen([
#     sys.executable,
#     "-m",
#     "cli.prerender",
#     "--url",
#     url_with_port.strip()
# ])


# English: Asynchronous main function to run the application server.
# Español: Función principal asíncrona para ejecutar el servidor de la aplicación.
async def main():
    # English: Starting the Uvicorn server with the application instance.
    # Español: Iniciando el servidor Uvicorn con la instancia de la aplicación.
    uvicorn.run("main:app", host=HOST, port=PORT, reload=True)


# English: Entry point for the script, running the main asynchronous function.
# Español: Punto de entrada del script, ejecutando la función principal asíncrona.
if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        # English: Gracefully shutting down the application on keyboard interrupt.
        # Español: Apagando la aplicación de manera ordenada al interrumpir con el teclado.
        print("Shutting down the application...")
        pass
</code>
</pre>
                                </div>
                            </div>
                        </article>

                        <article id="routes-esp">
                            <h1>Rutas</h1>

                            <p>Las rutas son los puntos de acceso a la aplicación. En Lila, las rutas se definen en el
                                directorio
                                <code>routes</code>(por defecto, pero puede ser donde tu quieras) y se importan en
                                <code>main.py</code> para su uso. Las rutas pueden ser
                                configuradas para manejar solicitudes HTTP, métodos de API, y más.
                            <p>
                                Además de JSONResponse puedes utilizar HTMLResponse,
                                RedirectResponse y PlainTextResponse, o
                                StreamingResponse , Para transmitir datos en tiempo
                                real (útil para streaming de video/audio o
                                respuestas grandes).

                            </p>
                            A continuación, se muestra un
                            ejemplo de cómo se definen las rutas en Lila:
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">routes/api.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                        <code class="language-python">
#Importar para las respuestas JSONResponse .
from lila.core.responses import JSONResponse 

#Administra las rutas para los puntos finales de la API.
from lila.core.routing import Router  
#Inicializa la instancia del enrutador para manejar rutas de la API.
router = Router()


# Define una ruta de API simple que soporta el método GET.
@router.route(path='/api', methods=['GET'])
async def api(request: Request):
    """Api function"""
    #Español: Devuelve una respuesta JSON simple para la verificación de la API.
    return JSONResponse({'api': True})   
                        </code>
                    </pre>
                                </div>
                            </div>
                            <br />
                            <h5>Recibir parametros por GET</h5>
                            <p>En esta función, recibimos un parámetro a través de la URL usando <code>{param}</code>.
                                Si el
                                parámetro no se envía, se asigna el valor por defecto <code>'default'</code>. La
                                respuesta es un
                                JSON con el valor recibido.</p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Recepción de Parámetros GET</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                            <code class="language-python">
@router.route(path='/url_with_param/{param}', methods=['GET']) 
async def param(request: Request):  
    param = request.path_params.get('param', 'default') 
    return JSONResponse({"received_param": param})
                            </code>
                            </pre>
                                </div>
                            </div>
                            <br />
                            <p>O también puedes hacerlo de esta manera</p>

                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Receiving GET Query parameters</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
    <code class="language-python"> 
@router.route(path='/url_with_param/?query_param', methods=['GET','POST']) 
async def query_param(request: Request):  
query_param= request.query_params.get('query_param', 'query_param')
return JSONResponse({"received_param": query_params})
                        
    </code>
    </pre>
                                </div>
                            </div>

                            <br />
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Imports básicos</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                        <code class="language-python">
from lila.core.responses import JSONResponse  # Simplifica el envío de respuestas JSON.
from lila.core.routing import Router  # Administra las rutas de la API.
from lila.core.request import Request  # Maneja solicitudes HTTP en la aplicación.
from pydantic import EmailStr, BaseModel  # Valida y analiza modelos de datos para la validación de entradas.
from app.helpers.helpers import get_user_by_id_and_token
from app.middlewares.middlewares import validate_token

router = Router()
                        </code>
                        </pre>
                                </div>
                            </div>

                            <h5>Uso de Middlewares y Decoradores</h5>
                            <p>Los middlewares permiten interceptar solicitudes antes de que lleguen a la lógica
                                principal de la
                                API. En este ejemplo, usamos <code>@validate_token</code> para validar un token JWT en
                                el header
                                de
                                la solicitud.</p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Validación con Middleware</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                        <code class="language-python">
@router.route(path='/api/token', methods=['GET','POST'])
@validate_token  # Middleware para validar el token JWT.
async def api_token(request: Request):
    return JSONResponse({'api': True})
                        </code>
                        </pre>
                                </div>
                            </div>

                            <h5>Validación de Datos con Pydantic</h5>
                            <p>Pydantic permite definir modelos de datos que validan automáticamente la entrada del
                                usuario.
                                Además,
                                al especificar un modelo en la ruta, se genera documentación automática en
                                <code>/docs</code>.
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Validación con Pydantic</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                        <code class="language-python">
from pydantic import EmailStr, BaseModel 
class ExampleModel(BaseModel):
    email: EmailStr  # Garantiza que el email es válido.
    password: str  # Cadena de texto para la contraseña.

@router.route(path='/api/example', methods=['POST'], model=ExampleModel)
async def login(request: Request):
    body = await request.json()
    try:
        input = ExampleModel(**body)  # Validación automática con Pydantic.
    except Exception as e:
        return JSONResponse({"success": False, "msg": f"Invalid JSON Body: {e}"}, status_code=400) 
    return JSONResponse({"email": input.email, "password": input.password})
                        </code>
                        </pre>
                                </div>
                            </div>

                            <h5>Generación Automática de Documentación</h5>
                            <p>Gracias a la integración con Pydantic, la documentación de la API se genera
                                automáticamente y es
                                accesible desde <code>/docs</code>. También se puede generar un archivo JSON de OpenAPI
                                para
                                herramientas externas.</p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Generación de Documentación</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                        <code class="language-python">
router.swagger_ui()  # Habilita Swagger UI para la documentación de la API.
router.openapi_json()  # Genera JSON de OpenAPI para herramientas externas.
                        </code>
                        </pre>
                                </div>
                            </div>


                            <h5>Importación de Rutas en main.py</h5>
                            <p>Para usar las rutas definidas en el router, es necesario obtenerlas con
                                <code>router.get_routes()</code> e importarlas en <code>main.py</code>.
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Importación de Rutas</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                        <code class="language-python">
routes = router.get_routes()  # Obtiene todas las rutas definidas.
                        </code>
                        </pre>
                                </div>
                            </div>
                        </article>

                        <article id="static-esp">
                            <h1>Archivos estáticos</h1>
                            <p>Para cargar archivos estáticos(js,css,etc) se puede utilizar el método
                                <code>mount()</code>.
                            </p>
                            <p>Qué se recibirá
                                como parámetros que se intercambian por defecto.
                                <code>path: str = '/public', directory: str = 'static', name: str = 'static'</code>
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Estático</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimum"></div>
                                        <div class="control maximum"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                <code class="language-python">
from lila.core.routing import Router
# Crear una instancia de Router para definir las rutas, si no se creó previamente en el archivo
router = Router()
# Montar los archivos estáticos en la carpeta 'static', url = '/public' por defecto
router.mount()
                </code>
                </pre>
                                </div>
                            </div>
                        </article>



                        <article id="templates-esp">
                            <h1>Templates Render (Jinja2 + Lila JS)</h1>
                            <p><strong>
                                    En Lila, puedes usar Jinja2 para renderizar HTML con datos del servidor o Lila JS
                                    para crear componentes reactivos del lado del cliente,
                                    o incluso combinar ambos enfoques según tus necesidades.
                                </strong></p>

                            <section>
                                <h2>Opciones de Renderizado</h2>
                                <p>Lila ofrece tres enfoques para construir tu aplicación:</p>

                                <div class="feature-cards">
                                    <div class="card">
                                        <h3>1. Jinja2 Tradicional</h3>
                                        <p>Renderizado completo del lado del servidor usando templates Jinja2 con datos
                                            del contexto.</p>
                                        <div class="code-editor small">
                                            <div class="editor-content">
                                                <pre><code class="language-html">
&lt;p&gt;{{ translate['Welcome'] }} {{ user.name }}&lt;/p&gt;
                                                </code></pre>
                                            </div>
                                        </div>
                                        <p><strong>Ventajas:</strong> SEO perfecto, carga rápida inicial, simple.</p>
                                    </div>

                                    <div class="card">
                                        <h3>2. Lila JS (SPA)</h3>
                                        <p>Aplicación de una sola página completamente reactiva en el cliente.</p>
                                        <div class="code-editor small">
                                            <div class="editor-content">
                                                <pre><code class="language-html">
&lt;span data-bind="message"&gt;&lt;/span&gt;
&lt;input data-model="username"&gt;
                                                </code></pre>
                                            </div>
                                        </div>
                                        <p><strong>Ventajas:</strong> Experiencia de usuario fluida, sin recargas.</p>
                                    </div>

                                    <div class="card">
                                        <h3>3. Híbrido</h3>
                                        <p>Combina Jinja2 para estructura base y Lila JS para partes interactivas.</p>
                                        <div class="code-editor small">
                                            <div class="editor-content">
                                                <pre><code class="language-html">
&lt;div data-component="InteractivePart"&gt;&lt;/div&gt;
&lt;p&gt;{{ static_content }}&lt;/p&gt;
                                                </code></pre>
                                            </div>
                                        </div>
                                        <p><strong>Ventajas:</strong> Lo mejor de ambos mundos.</p>
                                    </div>
                                </div>
                            </section>

                            <section>
                                <h2>Render con Jinja2</h2>
                                <p><strong>
                                        En Lila, Jinja2 se usa por defecto para renderizar HTML templates y enviarlos al
                                        cliente.
                                        Con <code>context</code>, puedes pasar información como traducciones, datos,
                                        valores, listas, diccionarios o lo que necesites.
                                    </strong></p>

                                <p>Los parámetros que la función <code>render</code> de <code>lila.core.templates</code>
                                    puede recibir son:</p>
                                <div class="code-editor">
                                    <div class="editor-content">
                                        <pre><code class="language-python">
request: Request, 
template: str, 
context: dict = {}, 
theme_: bool = True,
translate: bool = True, 
files_translate: list = []
                                        </code></pre>
                                    </div>
                                </div>
                            </section>

                            <section>
                                <h2>Lila JS: Sistema Reactivo</h2>
                                <p>Lila JS es una librería minimalista para crear interfaces reactivas con JavaScript
                                    vanilla.</p>
                                <p><a href="https://github.com/seip25/Lila_js" target="_blank">Documentación</a></p>

                                <h3>Conceptos Clave</h3>
                                <div class="concept-grid">
                                    <div class="concept">
                                        <h4>Estado Reactivo</h4>
                                        <p>El estado es un objeto especial que cuando cambia, actualiza automáticamente
                                            la UI.</p>
                                        <div class="code-editor small">
                                            <div class="editor-content">
                                                <pre><code class="language-javascript">
state: () => ({
    email: '',
    password: ''
})
                                                </code></pre>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="concept">
                                        <h4>Two-Way Data Binding</h4>
                                        <p>Enlace bidireccional entre inputs y estado usando <code>data-model</code>.
                                        </p>
                                        <div class="code-editor small">
                                            <div class="editor-content">
                                                <pre><code class="language-html">
&lt;input data-model="email"&gt;
&lt;span data-bind="email"&gt;&lt;/span&gt;
                                                </code></pre>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="concept">
                                        <h4>Componentes</h4>
                                        <p>Unidades reutilizables con su propio estado, template y acciones.</p>
                                        <div class="code-editor small">
                                            <div class="editor-content">
                                                <pre><code class="language-javascript">
App.createComponent('Login', {
    template: 'login-template',
    state: () => ({...}),
    actions: {...}
});
                                                </code></pre>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="concept">
                                        <h4>Enrutamiento</h4>
                                        <p>Navegación cliente-side entre componentes.</p>
                                        <div class="code-editor small">
                                            <div class="editor-content">
                                                <pre><code class="language-javascript">
App.addRoute('/login', 'Login');
handleRouting();
                                                </code></pre>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </section>

                            <section>
                                <h2>Ejemplo Completo: Sistema de Autenticación</h2>
                                <p>Este ejemplo muestra cómo combinar Jinja2 para la estructura base y Lila JS para la
                                    interactividad.</p>

                                <h3>auth.html - Estructura Base</h3>
                                <div class="code-editor">
                                    <div class="editor-header">
                                        <span class="editor-title">templates/html/auth.html</span>
                                    </div>
                                    <div class="editor-content">
                                        <pre><code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang="{{lang}}"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;{{title}}&lt;/title&gt;
    &lt;link rel="stylesheet" href="/public/css/styles.css" /&gt;
    &lt;script src="/public/js/lila.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;main id="app-lila" class="container"&gt;&lt;/main&gt;
    {% include 'auth/login.html' with context %}
    {% include 'auth/register.html' with context %}
    {% include 'auth/footer.html' with context %}
    &lt;script&gt;
        handleRouting();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
                                        </code></pre>
                                    </div>
                                </div>
                                <p><strong>Explicación:</strong> Este archivo sirve como layout base usando Jinja2.
                                    Incluye:</p>
                                <ul>
                                    <li>Traducciones del contexto con <code>{{lang}}</code> y <code>{{title}}</code>
                                    </li>
                                    <li>Un contenedor principal <code>app-lila</code> donde se montarán los componentes
                                    </li>
                                    <li>Inclusión de templates parciales para login, registro y footer</li>
                                    <li>Inicialización del enrutador con <code>handleRouting()</code></li>
                                </ul>

                                <h3>login.html - Componente Reactivo</h3>
                                <div class="code-editor">
                                    <div class="editor-header">
                                        <span class="editor-title">templates/html/auth/login.html</span>
                                    </div>
                                    <div class="editor-content">
                                        <pre><code class="language-html">
&lt;template data-template="login-template"&gt;
    &lt;div class="flex center"&gt;
        &lt;article class="shadow rounded mx-m"&gt;
            &lt;h1 class="flex center"&gt;{{translate['login']}}&lt;/h1&gt;
            &lt;form data-action="loginFetch"&gt;
                &lt;div class="input-icon"&gt;
                    &lt;i class="icon-email"&gt;&lt;/i&gt;
                    &lt;input type="email" data-model="email" placeholder="Email" required /&gt;
                &lt;/div&gt;
                &lt;div class="input-icon"&gt;
                    &lt;i class="icon-lock"&gt;&lt;/i&gt;
                    &lt;input type="password" data-model="password" 
                            placeholder="{{translate['password']}}" required /&gt;
                &lt;/div&gt;
                &lt;button type="submit"&gt;{{translate['login']}}&lt;/button&gt;
            &lt;/form&gt;
            &lt;a href="/register" data-link&gt;{{translate['register']}}&lt;/a&gt;
        &lt;/article&gt;
    &lt;/div&gt;
    &lt;div data-component="Footer"&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    App.createComponent('Login', {
        template: 'login-template',
        state: () => ({
            email: '',
            password: ''
        }),
        actions: {
            loginFetch: async ({ state, event }) => {
                event.preventDefault();
                const data = { email: state.email, password: state.password };
                alert('Login: ' + JSON.stringify(data));
            }
        }
    });
    
    App.addRoute('/login', 'Login');
    App.addRoute('*', 'Login'); // Ruta por defecto
&lt;/script&gt;
                                        </code></pre>
                                    </div>
                                </div>
                                <p><strong>Características destacadas:</strong></p>
                                <ul>
                                    <li><strong>Two-way data binding:</strong> Los inputs con <code>data-model</code> se
                                        sincronizan automáticamente con el estado.</li>
                                    <li><strong>Acciones:</strong> <code>data-action</code> vincula el formulario al
                                        método <code>loginFetch</code>.</li>
                                    <li><strong>Componente anidado:</strong> El footer se incluye con
                                        <code>data-component="Footer"</code>.
                                    </li>
                                    <li><strong>Enrutamiento:</strong> Los links con <code>data-link</code> navegan sin
                                        recargar la página.</li>
                                    <li><strong>Combinación con Jinja2:</strong> Uso de <code>{{translate}}</code> para
                                        textos internacionalizados.</li>
                                </ul>

                                <h3>register.html - Componente con Validación</h3>
                                <div class="code-editor">
                                    <div class="editor-header">
                                        <span class="editor-title">templates/html/auth/register.html</span>
                                    </div>
                                    <div class="editor-content">
                                        <pre><code class="language-html">
&lt;template data-template="register-template"&gt;
    &lt;div class="flex center container"&gt;
        &lt;article class="shadow rounded mx-m"&gt;
            &lt;h1&gt;{{translate['register']}}&lt;/h1&gt;
            &lt;form data-action="registerFetch"&gt;
                &lt;input type="text" data-model="name" placeholder="{{translate['name']}}"&gt;
                &lt;input type="email" data-model="email" placeholder="Email"&gt;
                &lt;input type="password" data-model="password" placeholder="{{translate['password']}}"&gt;
                &lt;input type="password" data-model="password_2" placeholder="{{translate['confirm_password']}}"&gt;
                &lt;button type="submit"&gt;{{translate['register']}}&lt;/button&gt;
            &lt;/form&gt;
            &lt;div&gt;
                &lt;p&gt;Valores actuales:&lt;/p&gt;
                &lt;p&gt;Nombre: &lt;span data-bind="name"&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;p&gt;Email: &lt;span data-bind="email"&gt;&lt;/span&gt;&lt;/p&gt;
            &lt;/div&gt;
            &lt;a href="/login" data-link&gt;{{translate['login']}}&lt;/a&gt;
        &lt;/article&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    App.createComponent('Register', {
        template: 'register-template',
        state: () => ({
            name: '',
            email: '',
            password: '',
            password_2: ''
        }),
        actions: {
            registerFetch: async ({ state, event }) => {
                event.preventDefault();
                if (state.password !== state.password_2) {
                    alert("{{translate['passwords_dont_match']}}");
                    return;
                }
                const data = { 
                    name: state.name, 
                    email: state.email, 
                    password: state.password 
                };
                // Enviar datos al servidor...
            }
        }
    });
    
    App.addRoute('/register', 'Register');
&lt;/script&gt;
                                        </code></pre>
                                    </div>
                                </div>
                                <p><strong>Puntos clave:</strong></p>
                                <ul>
                                    <li>Muestra en tiempo real los valores del estado con <code>data-bind</code></li>
                                    <li>Validación básica directamente en la acción</li>
                                    <li>Uso combinado de datos reactivos y traducciones estáticas</li>
                                </ul>

                                <h3>footer.html - Componente Simple</h3>
                                <div class="code-editor">
                                    <div class="editor-header">
                                        <span class="editor-title">templates/html/auth/footer.html</span>
                                    </div>
                                    <div class="editor-content">
                                        <pre><code class="language-html">
&lt;template data-template="footer-template"&gt;
    &lt;footer class="mt-4 container"&gt;
        &lt;div class="flex between"&gt;
            &lt;a href="/set-language/es"&gt;Español&lt;/a&gt;
            &lt;a href="/set-language/en"&gt;English&lt;/a&gt;
        &lt;/div&gt;
    &lt;/footer&gt;
&lt;/template&gt;

&lt;script&gt;
    App.createComponent('Footer', {
        template: 'footer-template'
    }); 
&lt;/script&gt;
                                        </code></pre>
                                    </div>
                                </div>
                                <p><strong>Notas:</strong></p>
                                <ul>
                                    <li>Componente sin estado (stateless)</li>
                                    <li>Reutilizable en cualquier parte de la aplicación</li>
                                    <li>No requiere lógica JavaScript compleja</li>
                                </ul>
                            </section>

                            <section>
                                <h2>Ventajas de este Enfoque</h2>
                                <div class="advantages">
                                    <div class="advantage">
                                        <h3>🚀 Rendimiento</h3>
                                        <p>Combina la velocidad inicial de Jinja2 con la fluidez de una SPA.</p>
                                    </div>
                                    <div class="advantage">
                                        <h3>🔍 SEO Optimizado</h3>
                                        <p>El contenido crítico se renderiza en el servidor para los bots de búsqueda.
                                        </p>
                                    </div>
                                    <div class="advantage">
                                        <h3>💡 Progresivo</h3>
                                        <p>Puedes empezar con Jinja2 y añadir interactividad donde se necesite.</p>
                                    </div>
                                    <div class="advantage">
                                        <h3>🛠️ Simple</h3>
                                        <p>Sin configuración compleja ni dependencias pesadas.</p>
                                    </div>
                                </div>
                            </section>

                            <section>
                                <h2>Referencia Rápida de Lila JS</h2>
                                <table class="reference-table">
                                    <thead>
                                        <tr>
                                            <th>Atributo/Función</th>
                                            <th>Descripción</th>
                                            <th>Ejemplo</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><code>data-component</code></td>
                                            <td>Monta un componente dentro de otro</td>
                                            <td><code>&lt;div data-component="Footer"&gt;&lt;/div&gt;</code></td>
                                        </tr>
                                        <tr>
                                            <td><code>data-bind</code></td>
                                            <td>Muestra el valor de una propiedad del estado</td>
                                            <td><code>&lt;span data-bind="email"&gt;&lt;/span&gt;</code></td>
                                        </tr>
                                        <tr>
                                            <td><code>data-model</code></td>
                                            <td>Two-way binding para inputs</td>
                                            <td><code>&lt;input data-model="username"&gt;</code></td>
                                        </tr>
                                        <tr>
                                            <td><code>data-action</code></td>
                                            <td>Asocia una acción a un evento</td>
                                            <td><code>&lt;button data-action="submit"&gt;</code></td>
                                        </tr>
                                        <tr>
                                            <td><code>data-link</code></td>
                                            <td>Navegación entre rutas sin recargar</td>
                                            <td><code>&lt;a href="/about" data-link&gt;</code></td>
                                        </tr>
                                        <tr>
                                            <td><code>App.createComponent</code></td>
                                            <td>Crea un nuevo componente</td>
                                            <td><code>App.createComponent('Login', {...});</code></td>
                                        </tr>
                                        <tr>
                                            <td><code>App.addRoute</code></td>
                                            <td>Define una ruta para un componente</td>
                                            <td><code>App.addRoute('/login', 'Login');</code></td>
                                        </tr>
                                        <tr>
                                            <td><code>handleRouting()</code></td>
                                            <td>Inicia el sistema de enrutamiento</td>
                                            <td><code>&lt;script&gt;handleRouting();&lt;/script&gt;</code></td>
                                        </tr>
                                    </tbody>
                                </table>
                            </section>
                        </article>
                        <article id="react-seo">
                            <h1>Integración de React con Lila</h1>

                            <p>
                                Lila proporciona una integración fluida con React, permitiéndote desarrollar tu frontend
                                con una
                                configuración modificada de Vite + React, manteniendo fuertes capacidades de SEO, caché
                                e hidratación
                                de HTML. Esta configuración asegura que tu aplicación React pueda prerenderizarse y ser
                                reconocida
                                por Google Bots y sistemas de IA.
                            </p>

                            <h5>Iniciando un Proyecto React en Lila</h5>
                            <p>
                                Para crear o ejecutar un proyecto React dentro de Lila, ejecuta el siguiente comando:
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Comando CLI</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-bash">
# Para entornos Python 3
python3 -m cli.react [--name NOMBRE_DEL_PROYECTO]

# O si tu Python por defecto es python
python -m cli.react [--name NOMBRE_DEL_PROYECTO]
            </code></pre>
                                </div>
                            </div>

                            <p>
                                <strong>Parámetros:</strong><br>
                                <code>--name</code>: Nombre opcional del proyecto, por defecto <code>"react"</code>.
                            </p>

                            <h5>Configuración CORS para Desarrollo</h5>
                            <p>
                                Al ejecutar React en modo desarrollo, Lila edita automáticamente <code>main.py</code>
                                para agregar la
                                configuración CORS necesaria. Por defecto:
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Fragmento de CORS en main.py</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
# Inglés: for development react
# Español: para desarrollo react
cors = {
    "origin": ["http://localhost:5173"],
    "allow_credentials": True,
    "allow_methods": ["*"],
    "allow_headers": ["*"]
}
            </code></pre>
                                </div>
                            </div>

                            <h5>Rutas Automáticas y Montaje de Assets</h5>
                            <p>
                                Lila modifica <code>app/routes/routes.py</code> automáticamente para tu build de React.
                                Esto asegura
                                que los assets del build se sirvan correctamente y que <code>index.html</code> se
                                renderice desde la
                                caché.
                            </p>


                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Ejemplo de routes.py</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
router.mount(path="/assets", directory="templates/html/react/assets", name="react-assets")

@router.route(path="/{path:path}", methods=["GET"])
async def home(request: Request):
    response = render(request=request, template="react/index")
    return response
            </code></pre>
                                </div>
                            </div>
                           <div>
                             <h3>
                                Recuerda modificar en el archivo <code>main.py</code> , cuando vayas a pasar tus rutas
                                para inicializar
                                la aplicación , pasa siempre primero <strong>api_routes</strong> o como tu le hayas
                                puesto.
                                <br /> Esto es clave para que tome tus rutas de api, sin colisionar con la ruta general
                                de React <code>
            @router.route(path="/{path:path}", methods=["GET"])
        </code>
                                , donde React , con React Router o lo que utilices pueda manejar todas las rutas .
                                <br /> Quedando de esta forma en <code>main.py</code>

                            </h3>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">main.py</span>
                                </div>
                                <div class="editor-content">
                                    <pre>
                                <code class="language-python">
all_routes = list(itertools.chain( api_routes,routes)) 
#Primero api_routes, luego routes (donde esta la ruta general de React)                                    <pre><code class="language-python">
         </code>
        </pre>
                                </div>
                            </div>

                           </div>
                            <h5>Prerender y Caché</h5>
                            <p>
                                Para mejorar el SEO, Lila soporta prerenderizar tus páginas React y guardarlas en caché.
                                Después de
                                ejecutar <code>npm run build</code>, puedes generar el HTML en caché:
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Generar Caché</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-bash">
python -m cli.prerender --url http://localhost:8001
# o python3 -m cli.prerender
            </code></pre>
                                </div>
                            </div>

                            <p>
                                Luego, en tu archivo de desarrollo <code>react/index.html</code>, incluye el HTML en
                                caché para la
                                hidratación y SEO:
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Fragmento index.html</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-html">
<div id="root">{% include "react/cache/index.html" ignore missing %}</div>
            </code></pre>
                                </div>
                            </div>

                            <h5>Integración de Prerender en main.py</h5>
                            <p>
                                Opcionalmente, puedes ejecutar el prerender automáticamente al iniciar el servidor
                                descomentando
                                la siguiente sección en <code>main.py</code>:
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">main.py prerender al inicio</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
# import subprocess
# import sys

# @app.on_event("startup")
# async def startup_event():
#     print("♻️ Prerender para React...")
#     url_with_port = f"http://{HOST}:{PORT}"
#     subprocess.Popen([
#         sys.executable,
#         "-m",
#         "cli.prerender",
#         "--url",
#         url_with_port.strip()
#     ])
            </code></pre>
                                </div>
                            </div>

                            <h5>SEO e Hidratación</h5>
                            <p>
                                Al incluir el HTML en caché dentro del <code>div</code> con id <code>root</code>, React
                                rehidrata
                                el contenido del lado del cliente. Esto permite:
                            </p>
                            <ul>
                                <li>Fuerte reconocimiento SEO por Google Bots y sistemas de IA.</li>
                                <li>Pintado inicial más rápido con HTML prerenderizado.</li>
                                <li>Caché diario opcional usando una tarea programada de prerender.</li>
                            </ul>

                            <h5>Helpers y Contexto para React</h5>
                            <p>
                                Puedes pasar contexto desde plantillas Jinja2 a React usando etiquetas
                                <code>&lt;script&gt;</code>
                                en <code>templates/html/react/index.html</code>. Útil para traducciones, configuración o
                                cualquier
                                dato dinámico.
                            </p>

                            <h5>Documentación Automática de API</h5>
                            <p>
                                Lila genera automáticamente la documentación de API usando modelos Pydantic. Todos los
                                helpers
                                y middlewares se pueden combinar perfectamente con las rutas React.
                            </p>

                            <h5>Validación de Sesión con React</h5>
                            <p>
                                En el backend, puedes agregar un middleware para validar la sesión. También puedes usar JWT, pero la Sesión es más segura porque está firmada por <code>itsdangerous</code>.
                            </p>
                            <p>
                                De esta forma, puedes validar peticiones y guardar IDs públicos, tokens, etc., para validar sesiones, o puedes usar JWT o ambos.
                                La recomendación principal es validar la sesión de esta manera o con <code>login_required</code>, que es otro middleware que también se puede configurar allí.
                                De esta forma, Lila y React quedan conectados para el desarrollador. En producción, gracias a la condición <code>if DEBUG</code>, será seguro con la firma de <code>itsdangerous</code> en la clase <code>Session</code>.
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">app/routes/api.py</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from app.middlewares.middlewares import login_required_auth, check_token, check_session
from lila.core.session import Session
from app.config import DEBUG

# Español: Define una ruta de API simple que soporta el método GET.
@router.route(path="/api", methods=["GET"])
async def api(request: Request):
    """Api function"""
    # Español: Devuelve una respuesta JSON simple para la verificación de la API.
    response = JSONResponse({"api": True})
    new_val={"id":20}
    samesite="none" if DEBUG else "secure"
    Session.setSession(new_val=new_val,name_cookie='auth',response=response,samesite=samesite)
    return response


# Español: Define una ruta de API que soporta los métodos GET y POST.
@router.route(path="/api/token", methods=["GET", "POST"])
# Español: Middleware para validar token de JWT.
@login_required_auth
async def api_token(request: Request):
    """Api Token function"""
    print(Session.getSessionValue(request=request))
    return JSONResponse({"api": True})
                                    </code></pre>
                                </div>
                            </div>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">app/middlewares/middlewares.py</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
def login_required_auth(func, key: str = "auth"):
    @wraps(func)
    async def wrapper(request, *args, **kwargs):
        session_data = Session.getSession(request=request,key=key)
        if not session_data:
            return JSONResponse({"session": False, "success": False}, status_code=401)
        return await func(request, *args, **kwargs)
                                    </code></pre>
                                </div>
                            </div>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Componente de React</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-javascript">
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    const start = async () => {
      const resp = await fetch('http://127.0.0.1:8000/api', { credentials: 'include' });

      const resp_ = await fetch('http://127.0.0.1:8000/api/token', { credentials: 'include' });
      const json = await resp_.json();

      console.log(json);
    };
    start();
  }, []);

  return (
    &lt;div&gt;
      {/* Tu JSX de componente */}
    &lt;/div&gt;
  );
}
                                    </code></pre>
                                </div>
                            </div>
                        </article>


                        <article id="lila-js-esp">
                            <h1>Documentación de Lila JS</h1>
                            <p>
                                Lila JS es un micro-framework de JavaScript minimalista para construir aplicaciones web
                                modernas. Proporciona un sistema reactivo, enrutamiento y componentes en un paquete
                                ligero.
                            </p>

                            <h2>Conceptos Centrales</h2>

                            <h3>Componentes</h3>
                            <p>
                                Los componentes son los bloques de construcción de una aplicación Lila JS. Encapsulan
                                una plantilla, estado y acciones.
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Ejemplo de Componente</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-javascript">
App.createComponent('Home', {
    template: 'home-template',
    state: () => ({
        message: '¡Bienvenido a Lila JS!'
    }),
    actions: {
        updateMessage: ({ state }) => {
            state.message = '¡El mensaje ha sido actualizado!';
        }
    }
});
                                    </code></pre>
                                </div>
                            </div>

                            <h3>Enrutamiento</h3>
                            <p>
                                Lila JS incluye un enrutador simple para mapear URLs a componentes.
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Ejemplo de Enrutamiento</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-javascript">
App.addRoute('/', 'Home');
App.addRoute('/about', 'About');
                                    </code></pre>
                                </div>
                            </div>

                            <h3>Inicialización</h3>
                            <p>
                                Para iniciar la aplicación y manejar el enrutamiento, necesitas llamar a
                                `handleRouting()`.
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Ejemplo de Inicialización</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-javascript">
handleRouting();
                                    </code></pre>
                                </div>
                            </div>
                        </article>

                        <article id="api-reference-esp">
                            <h1>Referencia de API y Ejemplos</h1>

                            <h2>Ejemplo de Formulario de Login</h2>
                            <p>
                                Este ejemplo demuestra cómo crear un formulario de login simple con validación.
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Componente de Login</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-html">
&lt;template data-template="login-template"&gt;
    &lt;form data-action="login"&gt;
        &lt;input type="email" data-model="email" placeholder="Correo electrónico" required&gt;
        &lt;input type="password" data-model="password" placeholder="Contraseña" required&gt;
        &lt;button type="submit"&gt;Iniciar sesión&lt;/button&gt;
    &lt;/form&gt;
&lt;/template&gt;

&lt;script&gt;
    App.createComponent('Login', {
        template: 'login-template',
        state: () => ({
            email: '',
            password: ''
        }),
        actions: {
            login: ({ state, event }) => {
                event.preventDefault();
                if (state.email && state.password) {
                    // Realizar la lógica de inicio de sesión aquí
                    console.log('Iniciando sesión con:', state.email, state.password);
                } else {
                    alert('Por favor, complete todos los campos.');
                }
            }
        }
    });

    App.addRoute('/login', 'Login');
&lt;/script&gt;
                                    </code></pre>
                                </div>
                            </div>
                        </article>


                        <article id="upload-esp">
                            <h1>Helper para Subida de Archivos</h1>
                            <p><strong>
                                    El helper <code>upload</code> proporciona una solución completa para manejar subidas
                                    de archivos en tu aplicación,
                                    incluyendo validación, controles de seguridad y soporte para traducciones.
                                </strong></p>

                            <p>Este helper maneja automáticamente:
                            <ul>
                                <li>Validación del método HTTP (solo POST)</li>
                                <li>Validación del Content-Type (multipart/form-data)</li>
                                <li>Validación de extensiones de archivo</li>
                                <li>Límites de tamaño de archivo</li>
                                <li>Detección de archivos vacíos</li>
                                <li>Manejo seguro de nombres de archivo</li>
                                <li>Creación automática de directorios</li>
                                <li>Soporte para traducción de mensajes de error</li>
                            </ul>
                            </p>

                            <h2>Parámetros</h2>
                            <p>La función <code>upload</code> acepta estos parámetros:</p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Parámetros</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
request: Request          # Objeto request de Starlette
name_file: str | list     # Nombre del campo para subida (por defecto: 'file')
UPLOAD_DIR: str           # Directorio para guardar archivos (por defecto: 'uploads')
ALLOWED_EXTENSIONS: set   # Extensiones permitidas (por defecto: {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'})
MAX_FILE_SIZE: int        # Tamaño máximo en bytes (por defecto: 10MB)
                                    </code></pre>
                                </div>
                            </div>

                            <h2>Ejemplo de Uso</h2>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Implementación en Ruta</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from app.helpers.helpers import upload

@router.route("/upload", methods=["POST"])
async def uploadFile(request: Request):
    response = await upload(request=request, name_file="file")
    return response
                                    </code></pre>
                                </div>
                            </div>

                            <h2>Implementación en Frontend</h2>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">HTML + JavaScript</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-html">
&lt;form onsubmit="upload(event);"&gt;
    &lt;fieldset&gt;
        &lt;input type="file" name="file" required&gt;
    &lt;/fieldset&gt;
    &lt;button type="submit"&gt;
        &lt;i class="icon-check-circle"&gt;&lt;/i&gt;
        Subir Archivos
    &lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
    async function upload(event) {
        event.preventDefault();
        const formElement = event.target;
        const formData = new FormData(formElement);
        
        try {
            const response = await fetch('/upload', {
                method: 'POST',
                body: formData,
            });
            
            const result = await response.json();
            if (!response.ok) throw new Error(result.message);
            
            alert('¡Archivo subido correctamente!');
        } catch (error) {
            alert(error.message);
        }
    }
&lt;/script&gt;
                                    </code></pre>
                                </div>
                            </div>

                            <h2>Formato de Respuesta</h2>
                            <p>El helper retorna un JSONResponse con esta estructura:</p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Respuesta Exitosa</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-json">
{
    "file": "/uploads/nombre_archivo.ext",
    "success": true,
    "message": "Archivo subido correctamente"
}
                                    </code></pre>
                                </div>
                            </div>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Respuesta de Error</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-json">
{
    "error": true,
    "success": false,
    "message": "Mensaje de error en el idioma del usuario"
}
                                    </code></pre>
                                </div>
                            </div>
                        </article>

                        <article id="markdown-esp">
                            <h1>Markdown /HTML</h1>
                            <p>Para renderizar archivos <code>markdown</code> se utiliza la función
                                <code>renderMarkdown</code>, que recibe los siguientes parámetros:
                                <code>request,file : str , base_path:str ='templates/markdown/',css_files : list = [],js_files:list=[],picocss : bool =False</code>
                            </p>
                            <p>
                                <code>file</code> es el nombre del archivo, comenzando desde la <code>base_path</code>
                                del
                                directorio
                                ubicado en <code>templates/markdown/</code>, por ejemplo: <code>index.md</code>.
                                Buscará un archivo <code>index.md</code> en el directorio de Markdown dentro de la
                                carpeta de
                                plantillas
                                (templates/markdown/index.md).
                            </p>
                            <p>
                                <code>css_files</code> y <code>js_files</code> son listas de archivos CSS y JS que se
                                cargarán
                                en el
                                archivo HTML generado.
                            </p>
                            <p>
                                <code>picocss</code> es un valor booleano que indica si se debe cargar el archivo CSS
                                PicoCSS.
                            </p>
                            <p>
                                A continuación, se muestra un ejemplo de cómo se representan los archivos
                                <code>markdown</code>
                                en
                                Lilac:
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Markdown</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimum"></div>
                                        <div class="control maximum"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                <code class="language-python">
from lila.core.templates import renderMarkdown

@router.route(path='/markdown', methods=['GET'])
async def home(request: Request):
#Define una lista de archivos CSS para incluir en la respuesta
css = ["/public/css/styles.css"]
#Representa un archivo markdown con estilo PicoCSS
response = renderMarkdown(request=request, file='example', css_files=css, picocss=True)
return response
                
                </code>
                </pre>
                                </div>
                            </div>

                        </article>

                        <article id="locales-esp">
                            <h1>Internalización (Traducciones)</h1>
                            <p>Las traducciones se utilizan para internacionalizar una aplicación y mostrar contenido en
                                diferentes idiomas. En Lila, las traducciones se almacenan en el directorio
                                <code>app/locales</code> y se pueden cargar dinámicamente en la aplicación.
                            </p>

                            <h2>Forzar idioma por defecto en rutas</h2>
                            <p>El método <code>render</code> acepta un parámetro <code>lang_default</code> para forzar
                                un idioma específico en la plantilla renderizada:</p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">app/routes.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
# Forzar idioma español
@router.route(path="/es", methods=["GET"])
async def home(request: Request):
    response = render(
        request=request,
        template="index",
        lang_default="es"  # Fuerza traducciones en español
    )
    return response

# Forzar idioma inglés
@router.route(path="/en", methods=["GET"])
async def home(request: Request):
    response = render(
        request=request,
        template="index",
        lang_default="en"  # Fuerza traducciones en inglés
    )
    return response
                                    </code></pre>
                                </div>
                            </div>

                            <h2>Archivos de traducción</h2>
                            <p>Para cargar un archivo de locales, usa la función <code>translate</code> desde
                                <code>app.helpers.helpers</code>. Puedes acceder a las traducciones usando:
                            </p>
                            <ul>
                                <li><code>translate</code> - devuelve un diccionario con todas las traducciones</li>
                                <li><code>translate_</code> - devuelve una traducción específica (devuelve el texto
                                    original si no se encuentra)</li>
                            </ul>

                            <p>Ejemplo de archivo de traducción (<code>app/locales/translations.json</code>):</p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">app/locales/translations.json</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-json">
{
    "Send": {
        "es": "Enviar",
        "en": "Send"
    },
    "Cancel": {
        "es": "Cancelar",
        "en": "Cancel"
    },
    "Accept": {
        "es": "Aceptar",
        "en": "Accept"
    },
    "Email": {
        "es": "Email",
        "en": "Email"
    },
    "Name": {
        "es": "Nombre",
        "en": "Name"
    },
    "Back": {
        "es": "Volver",
        "en": "Back"
    },
    "Hi": {
        "es": "Hola",
        "en": "Hi"
    }
}
                                    </code></pre>
                                </div>
                            </div>

                            <h2>Usando traducciones</h2>
                            <p>Obtener una traducción específica:</p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">example.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from app.helpers.helpers import translate_

msg_error_login = translate_(
    key="Incorrect email or password", 
    request=request, 
    file_name="guest"
)
                                    </code></pre>
                                </div>
                            </div>

                            <p>Obtener todas las traducciones de un archivo:</p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">example.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from app.helpers.helpers import translate

all_translations = translate(
    request=request, 
    file_name="guest"
)
                                    </code></pre>
                                </div>
                            </div>

                            <h2>Configuración adicional</h2>
                            <p>También puedes utilizar el helper <code>lang</code> para obtener el idioma actual basado
                                en la sesión o configuración de la aplicación:</p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">example.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from app.helpers.helpers import lang

current_language = lang(request)
                                    </code></pre>
                                </div>
                            </div>
                        </article>

                        <article id="models-esp">
                            <h1>Modelos (SQLAlchemy)</h1>
                            <h5>Los modelos se utilizan para definir la estructura de los datos en la aplicación.</h5>

                            <p>
                                <a href="https://www.sqlalchemy.org/" target="_blank">SQLAlchemy</a> es el ORM
                                predeterminado
                                para
                                la gestión de bases de datos.
                                SQLAlchemy permite crear modelos de base de datos, ejecutar consultas y manejar
                                migraciones de
                                manera eficiente.
                            </p>

                            <h2>Uso de Modelos</h2>
                            <p>
                                La clase `Base`, importada desde `lila.core.database`, sirve como base para todos los
                                modelos.
                                Los modelos heredan de `Base` para definir las tablas de la base de datos con
                                SQLAlchemy.
                            </p>

                            <h2>Ejemplo: Modelo de Usuario</h2>
                            <p>
                                Este ejemplo muestra cómo crear un modelo `User` utilizando SQLAlchemy.
                                El modelo define una tabla `users` con columnas como `id`, `name`, `email`, `password`,
                                `token`,
                                `active` y `created_at`.
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">app/models/user.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                            <code class="language-python">
from sqlalchemy import Table, Column, Integer, String, TIMESTAMP
from sqlalchemy.orm import Session
from lila.core.database import Base
from app.connections import connection
from argon2 import PasswordHasher

ph = PasswordHasher()


class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(length=50), nullable=False)
    email = Column(String(length=50), unique=True)
    password = Column(String(length=150), nullable=False)
    token = Column(String(length=150), nullable=False)
    active = Column(Integer, nullable=False, default=1)
    created_at = Column(TIMESTAMP)

    #Ejemplo de como poder utilizar SQLAlchemy para hacer consultas a la base de datos
    def get_all(select: str = "id,email,name", limit: int = 1000) -> list:
        query = f"SELECT {select}  FROM users WHERE active =1  LIMIT {limit}"
        result = connection.query(query=query,return_rows=True)#Retornar todos los elementos
        return result 

    # Ejemplo de como poder utilizar SQLAlchemy para hacer consultas a la base de datos
    def get_by_id(id: int, select="id,email,name") -> dict:
        query = f"SELECT {select}  FROM users WHERE id = :id AND active = 1 LIMIT 1"
        params = {"id": id}
        row = connection.query(query=query, params=params,return_row=True)#Retorna un elemento
        return row

    #Ejemplo usando abstracción de ORM en SQLAlchemy
    @classmethod
    def get_all_orm(cls, db: Session, limit: int = 1000):
        result = db.query(cls).filter(cls.active == 1).limit(limit).all()
        return result


#Ejemplo de como usar la clase para realizar consultas a la base de datos
# users = User.get_all()
# user = User.get_by_id(1)

                            </code>
                        </pre>
                                </div>
                            </div>

                            <br />

                            <p>
                                Para más detalles sobre SQLAlchemy, visita la documentación oficial:
                                <a href="https://www.sqlalchemy.org/" target="_blank">Documentación de SQLAlchemy</a>.
                            </p>
                        </article>

                        <article id="middlewares-esp">
                            <h1>Middlewares</h1>
                            <h5>
                                Las funciones de middleware se utilizan para interceptar solicitudes antes de que
                                lleguen a la lógica principal de la aplicación.
                                En Lila, los middlewares se definen en el directorio <code>app/middlewares</code> (puede
                                modificarse a cualquier archivo y/o directorio).
                                Los middlewares se pueden utilizar para tareas como autenticación, registro y manejo de
                                errores.
                            </h5>
                            <p>
                                Por defecto, Lila incluye 3 middlewares para iniciar cualquier aplicación. Los
                                middlewares se pueden utilizar con decoradores <code>@my_middleware</code>.
                            </p>
                            <p>
                                <code>login_required</code>, para validar que tengas una sesión firmada, para la clave
                                'auth' que se pasa como parámetro para poder modificarla como desees.
                                Si no se encuentra esta sesión, redirige a la URL que se pasa como parámetro, por
                                defecto es <code>"/login"</code>.
                                De lo contrario, continuará su curso ejecutando la ruta o función.
                            </p>
                            <p>
                                Luego tenemos <code>session_active</code>, que se utiliza para verificar si tienes una
                                sesión activa.
                                Redirigirá a la URL que se recibe como parámetro, por defecto es
                                <code>"/dashboard"</code>.
                            </p>
                            <p>
                                El tercero es <code>validate_token</code>, que se utiliza para validar un token JWT
                                gracias a los helpers <code>get_token</code> importados en
                                <code>from app.helpers.helpers import get_token</code>.
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">app/middlewares/middlewares.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from lila.core.session import Session
from lila.core.responses import RedirectResponse, JSONResponse
from lila.core.request import Request
from functools import wraps
from app.helpers.helpers import get_token

def login_required(func, key: str = 'auth', url_return='/login'):
    @wraps(func)
    async def wrapper(request, *args, **kwargs):
        session_data = Session.unsign(key=key, request=request)
        if not session_data:
            return RedirectResponse(url=url_return)
        return await func(request, *args, **kwargs)
    return wrapper

def session_active(func, key: str = 'auth', url_return: str = '/dashboard'):
    @wraps(func)
    async def wrapper(request, *args, **kwargs):
        session_data = Session.unsign(key=key, request=request)
        if session_data:
            return RedirectResponse(url=url_return)
        return await func(request, *args, **kwargs)
    return wrapper

def validate_token(func):
    @wraps(func)
    async def wrapper(request: Request, *args, **kwargs):
        await check_token(request=request)
        return await func(request, *args, **kwargs)
    return wrapper

async def check_token(request: Request):
    token = request.headers.get('Authorization')
    if not token:
        return JSONResponse({'session': False, 'message': 'Token inválido'}, status_code=401)
    
    token = get_token(token=token)
    if isinstance(token, JSONResponse):
        return token
                                    </code></pre>
                                </div>
                            </div>

                            <br />
                            <h5>
                                Aquí te damos varios ejemplos de cómo usar los 3, con los decoradores.
                            </h5>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Middlewares en rutas</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
# Middleware para validar el token JWT.
@router.route(path='/api/token', methods=['GET', 'POST'])
@validate_token  # Middleware
async def api_token(request: Request):
    """Función Api Token"""
    print(get_user_by_id_and_token(request=request))
    return JSONResponse({'api': True})

# Middleware para validar sesión activa
@router.route(path='/dashboard', methods=['GET'])
@login_required  # Middleware
async def dashboard(request: Request):
    response = render(request=request, template='dashboard', files_translate=['authenticated'])
    return response

# Middleware para validar si el usuario tiene sesión activa (si el usuario tiene sesión, redirige a '/dashboard')
@router.route(path='/login', methods=['GET'])
@session_active  # Middleware
async def login(request: Request):
    response = render(request=request, template='auth/login', files_translate=['guest'])
    return response
                                    </code></pre>
                                </div>
                            </div>

                            <h2>Middleware de Seguridad</h2>
                            <p>
                                Lila Framework incluye un <code>ErrorHandlerMiddleware</code> integrado que no solo
                                maneja excepciones no controladas, sino que también proporciona verificaciones de
                                seguridad robustas para proteger tu aplicación de solicitudes maliciosas. Este
                                middleware está diseñado para bloquear IPs sospechosas, URLs y rutas sensibles,
                                asegurando que tu aplicación permanezca segura.
                            </p>
                            <h3>Características</h3>
                            <ul>
                                <li>
                                    <strong>Bloqueo de IPs</strong>:
                                    Bloquea direcciones IP que han sido marcadas por actividad maliciosa. Las IPs se
                                    bloquean durante 6 horas por defecto.
                                </li>
                                <li>
                                    <strong>Bloqueo de URLs</strong>:
                                    Bloquea URLs específicas que se sabe que son maliciosas o sospechosas.
                                </li>
                                <li>
                                    <strong>Bloqueo de Rutas Sensibles</strong>:
                                    Bloquea el acceso a rutas sensibles como <code>/etc/passwd</code>,
                                    <code>.env</code>, y otras.
                                </li>
                                <li>
                                    <strong>Bloqueo de Extensiones Maliciosas</strong>:
                                    Bloquea URLs que contienen extensiones de archivo maliciosas como <code>.php</code>,
                                    <code>.asp</code>, <code>.jsp</code> y <code>.aspx</code>.
                                    Dado que no ejecutamos dichas extensiones de los lenguajes mencionados, se bloquean
                                    para evitar
                                    posibles ataques.
                                </li>
                                <li>
                                    <strong>Detección de HTTP</strong>:
                                    Bloquea solicitudes que contienen <code>"http"</code> en los parámetros de consulta
                                    o en el contenido del cuerpo.
                                </li>
                            </ul>
                            <h3>Configuración</h3>
                            <p>
                                El middleware utiliza tres archivos JSON ubicados en el directorio
                                <code>app/security</code>:
                            </p>
                            <ul>
                                <li><code>blocked_ips.json</code>: Almacena las IPs bloqueadas con su tiempo de
                                    expiración.</li>
                                <li><code>blocked_urls.json</code>: Almacena las URLs bloqueadas con su tiempo de
                                    expiración.</li>
                                <li><code>sensitive_paths.json</code>: Almacena una lista de rutas sensibles para
                                    bloquear.</li>
                            </ul>
                            <p>
                                Si estos archivos no existen, se crean automáticamente y se inicializan con valores
                                predeterminados:
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">security/sensitive_paths.json</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-json">
[
    "/etc/passwd",
    ".env",
    "wp-content",
    "docker/.env",
    "owa/auth/logon.aspx",
    "containers/json",
    "models",
    "autodiscover/autodiscover.json",
    "heapdump",
    "actuator/heapdump",
    "cgi-bin/vitogate.cgi",
    "CFIDE/wizards/common/utils.cfc",
    "var/www/html/.env",
    "home/user/.muttrc",
    "usr/local/spool/mail/root",
    "etc/postfix/master.cf"
]
                                    </code></pre>
                                </div>
                            </div>
                            <h3>Uso</h3>
                            <p>
                                El <code>ErrorHandlerMiddleware</code> se aplica automáticamente a todas las
                                solicitudes. Puedes personalizar su comportamiento modificando los archivos JSON en el
                                directorio <code>security</code>.
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">core/middleware.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from starlette.middleware.base import BaseHTTPMiddleware
from lila.core.responses import JSONResponse, HTMLResponse
from lila.core.request import Request
from lila.core.logger import Logger
from datetime import datetime, timedelta
import json
import os

def load_blocked_data(file_path, default_value):
try:
    if not os.path.exists(file_path):
        with open(file_path, "w") as file:
            json.dump(default_value, file, indent=4)
        return default_value

    with open(file_path, "r") as file:
        content = file.read().strip()
        if not content:
            with open(file_path, "w") as file:
                json.dump(default_value, file, indent=4)
            return default_value

        try:
            return json.loads(content)
        except json.JSONDecodeError:
            with open(file_path, "w") as file:
                json.dump(default_value, file, indent=4)
            return default_value

except Exception as e:
    Logger.error(f"Error cargando {file_path}: {str(e)}")
    return default_value

def save_blocked_data(file_path, data):
try:
    with open(file_path, "w") as file:
        json.dump(data, file, indent=4)
except Exception as e:
    Logger.error(f"Error guardando {file_path}: {str(e)}")

async def is_blocked(blocked_data, key, request: Request):
if key in blocked_data:
    expiration_time = datetime.fromisoformat(blocked_data[key]["expiration_time"])
    if datetime.now() < expiration_time:
        req = await Logger.request(request=request)
        Logger.warning(f"Bloqueado: {key} \n {req}")
        return True
return False

class ErrorHandlerMiddleware(BaseHTTPMiddleware):
def __init__(
    self,
    app,
    blocked_ips_file="security/blocked_ips.json",
    blocked_urls_file="security/blocked_urls.json",
    sensitive_paths_file="security/sensitive_paths.json",
):
    super().__init__(app)
    self.blocked_ips_file = blocked_ips_file
    self.blocked_urls_file = blocked_urls_file
    self.sensitive_paths_file = sensitive_paths_file

    self.blocked_ips = load_blocked_data(blocked_ips_file, default_value={})
    self.blocked_urls = load_blocked_data(blocked_urls_file, default_value={})
    self.sensitive_paths = load_blocked_data(sensitive_paths_file, default_value=[])

async def dispatch(self, request, call_next):
    try:
        client_ip = request.client.host
        url_path = request.url.path
        query_params = str(request.query_params)
        body = await request.body()

        if await is_blocked(self.blocked_ips, client_ip, request=request):
            return HTMLResponse(
                content="<h1>Acceso Denegado</h1><p>Tu IP ha sido bloqueada temporalmente.</p>",
                status_code=403,
            )

        if await is_blocked(self.blocked_urls, url_path, request=request):
            return HTMLResponse(
                content="<h1>Acceso Denegado</h1><p>Esta URL ha sido bloqueada temporalmente.</p>",
                status_code=403,
            )

        malicious_extensions = [".php", ".asp", ".jsp", ".aspx"]
        if any(ext in url_path for ext in malicious_extensions):
            self.blocked_ips[client_ip] = {
                "expiration_time": (datetime.now() + timedelta(hours=6)).isoformat()
            }
            save_blocked_data(self.blocked_ips_file, self.blocked_ips)
            return HTMLResponse(
                content="<h1>Acceso Denegado</h1><p>Se detectó una URL maliciosa.</p>",
                status_code=403,
            )

        if "http" in query_params or "http" in str(body):
            self.blocked_ips[client_ip] = {
                "expiration_time": (datetime.now() + timedelta(hours=6)).isoformat()
            }
            save_blocked_data(self.blocked_ips_file, self.blocked_ips)
            return HTMLResponse(
                content="<h1>Acceso Denegado</h1><p>Se detectaron parámetros de consulta maliciosos.</p>",
                status_code=403,
            )

        if any(path in url_path or path in str(body) for path in self.sensitive_paths):
            self.blocked_ips[client_ip] = {
                "expiration_time": (datetime.now() + timedelta(hours=6)).isoformat()
            }
            save_blocked_data(self.blocked_ips_file, self.blocked_ips)
            return HTMLResponse(
                content="<h1>Acceso Denegado</h1><p>Se detectó una ruta sensible.</p>",
                status_code=403,
            )

        Logger.info(await Logger.request(request=request))
        response = await call_next(request)
        return response

    except Exception as e:
        Logger.error(f"Error no controlado: {str(e)}")
        return JSONResponse(
            {"error": "Error interno del servidor", "success": False}, status_code=500
        )
                                    </code></pre>
                                </div>
                            </div>
                        </article>

                        <article id="connections-esp">
                            <h1>Conexiones a la base de datos</h1>
                            <p>
                                Para utilizar conexiones, necesitas importar la clase <code>Database</code> desde
                                lila.core.database.
                                Con
                                eso podrás conectarte a tu base de datos, que puede ser SQLite, MySLQ, PostgreSQL o la
                                que
                                quieras configurar.
                            <p>A continuación te dejamos el ejemplo de cómo conectarte. La conexión se cerrará
                                automáticamente
                                luego
                                de ser utilizada, por lo que puedes utilizarla como en este ejemplo en la variable
                                <code>connection</code>
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">app/connections.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>

        <code class="language-python">
from lila.core.database import Database

#SQLite
config = {"type":"sqlite","database":"test"} #test.db
connection = Database(config=config)
connection.connect()

#MySql
config = {"type":"mysql","host":"127.0.0.1","user":"root","password":"password","database":"db_test","auto_commit":True}
connection = Database(config=config)
connection.connect()
mysql_connection = connection
            

            </code>
            </pre>
                                </div>
                            </div>
                        </article>

                        <article id="migrations-esp">
                            <h1>Migraciones</h1>
                            <p>En Lila Framework, las migraciones de base de datos se pueden gestionar usando SQLAlchemy
                                y la configuración de Lila
                                para hacer las migraciones lo más sencillas posible. El framework ahora soporta
                                migraciones por línea de comandos a través de Typer,
                                proporcionando una forma más intuitiva y flexible de gestionar el esquema de tu base de
                                datos.
                            </p>
                            <br />

                            <h2>Métodos de Migración</h2>
                            <p>Existen dos formas principales de definir tablas de base de datos:</p>

                            <h3>1. Usando Table</h3>
                            <p>Este método define manualmente la estructura de la tabla usando el objeto Table de
                                SQLAlchemy.</p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">cli/migrations.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from sqlalchemy import Table, Column, Integer, String, TIMESTAMP
from app.connections import connection
import typer
import asyncio

app = typer.Typer()

# Ejemplo de creación de migraciones para 'users'
table_users = Table(
    'users', connection.metadata,
    Column('id', Integer, primary_key=True, autoincrement=True),
    Column('name', String(length=50), nullable=False),
    Column('email', String(length=50), unique=True),
    Column('password', String(length=150), nullable=False),
    Column('token', String(length=150), nullable=False),
    Column('active', Integer, default=1, nullable=False),
    Column('created_at', TIMESTAMP),
)

async def migrate_async(connection, refresh: bool = False) -> bool:
    try:
        if refresh:
            connection.metadata.drop_all(connection.engine)
        connection.prepare_migrate([table_users])  # para tablas
        connection.migrate()
        print("Migraciones completadas")
        return True
    except RuntimeError as e:
        print(e)
        return False

@app.command()
def migrate(refresh: bool = False):
    """Ejecuta las migraciones de la base de datos"""
    success = asyncio.run(migrate_async(connection, refresh))
    if not success:
        raise typer.Exit(code=1)

if __name__ == "__main__":
    app()
                                    </code></pre>
                                </div>
                            </div>

                            <h3>2. Usando Models (Recomendado)</h3>
                            <p>Este enfoque define las tablas de la base de datos como clases Python que heredan de
                                "Base".
                                Este es el método recomendado ya que proporciona más estructura y capacidades ORM.</p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">app/models/user.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from lila.core.database import Base
from sqlalchemy import Column, Integer, String, TIMESTAMP

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(length=50), nullable=False)
    email = Column(String(length=50), unique=True)
    password = Column(String(length=150), nullable=False)
    token = Column(String(length=150), nullable=False)
    active = Column(Integer, nullable=False, default=1)
    created_at = Column(TIMESTAMP)
                                    </code></pre>
                                </div>
                            </div>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">cli/migrations.py (versión con Models)</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from app.connections import connection
from lila.core.database import Base  # Importar Base para migraciones con modelos
from app.models.user import User  # Importar modelos para las migraciones
import typer
import asyncio

app = typer.Typer()

async def migrate_async(connection, refresh: bool = False) -> bool:
    try:
        if refresh:
            connection.metadata.drop_all(connection.engine)
        connection.migrate(use_base=True)  # para modelos
        print("Migraciones completadas")
        return True
    except RuntimeError as e:
        print(e)
        return False

@app.command()
def migrate(refresh: bool = False):
    """Ejecuta las migraciones de la base de datos"""
    success = asyncio.run(migrate_async(connection, refresh))
    if not success:
        raise typer.Exit(code=1)

if __name__ == "__main__":
    app()
                                    </code></pre>
                                </div>
                            </div>

                            <h2>Ejecutando Migraciones</h2>
                            <p>Para ejecutar las migraciones, usa el siguiente comando en tu terminal:</p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Comando de Terminal</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-bash">
# Migración básica
python -m cli.migrations 

# Refrescar todas las tablas (eliminar y recrear)
python -m cli.migrations  --refresh
                                    </code></pre>
                                </div>
                            </div>

                            <h3>Opciones del Comando</h3>
                            <ul>
                                <li><code>migrate</code>: Ejecuta las migraciones de la base de datos</li>
                                <li><code>--refresh</code>: Opcional, elimina y recrea todas las tablas</li>
                            </ul>

                            <div class="note">
                                <p><strong>Nota:</strong> Cuando uses Models, asegúrate de importar todas tus clases de
                                    modelo en el archivo de migraciones
                                    para que SQLAlchemy pueda detectarlas para las migraciones.</p>
                            </div>
                        </article>

                        <article id="rest_api_crud-esp">
                            <h1>Generación sencilla de CRUD de API Rest</h1>
                            <h5>En Lila tenemos una forma sencilla para generar CRUDs con documentación automática,
                                permitiéndote crear tu API Rest de manera eficiente.</h5>

                            <p>Gracias a la combinación de los modelos de <strong>SQLAlchemy</strong> y
                                <strong>Pydantic</strong>, es posible realizar validaciones de datos y ejecutar
                                consultas de
                                manera estructurada para la generación de la API.
                            </p>

                            <p>Además, puedes integrar <strong>middlewares</strong> personalizados para validar tokens,
                                manejar
                                sesiones o procesar solicitudes. Con pocas líneas de código, puedes generar un CRUD de
                                API Rest
                                completamente documentado.</p>
                            <br />

                            <p>
                                <strong>Si no lo has hecho, habilitar las migraciones al encender el servidor</strong>
                                .
                                Por defecto utiliza SQLite, creara un archivo de base <code>lila.sqlite</code> en la
                                raíz del
                                proyecto.
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">term</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="bash">
python -m cli.migrations 
                                
                                    </code>
                                    </pre>
                                </div>
                            </div>
                            <br />

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">routes/api.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
from lila.core.request import Request 
from lila.core.responses import JSONResponse
from lila.core.routing import Router
from pydantic import EmailStr, BaseModel
from app.middlewares.middlewares import validate_token, check_token, check_session
from app.connections import connection  # Conexión a la base de datos con SQLAlchemy
from app.models.user import User  # Modelo 'User' de SQLAlchemy

router = Router()# Inicializa la instancia del enrutador para manejar rutas de la API.

# Modelo de Pydantic para validaciones al crear o modificar un usuario.
class UserModel(BaseModel):
    email: EmailStr
    name: str
    token: str
    password: str

# Definición de middlewares para las operaciones CRUD
middlewares_user = {
    "get": [],
    "post": [], 
    "get_id": [],
    "put": [],
    "delete": [check_session, check_token],#Ejemplo de middleware para sesión web con 'check_session' y jwt con 'check_token'
}

# Generación del CRUD automáticamente con validaciones y configuraciones
router.rest_crud_generate(
    connection=connection,  # Conexión a la base de datos
    model_sql=User,  # Modelo SQLAlchemy
    model_pydantic=UserModel,  # Modelo Pydantic
    select=["name", "email", "id", "created_at", "active"],  # Campos a seleccionar en las consultas
    delete_logic=True,  # Habilita el borrado lógico (actualiza 'active = 0' en lugar de eliminar registros)
    active=True,  # Filtra automáticamente los registros activos ('active = 1')
    middlewares=middlewares_user,  # Middlewares personalizados para cada acción CRUD
)
                            </code></pre>
                                </div>
                            </div>

                            <br />
                            <p>Puedes crear tus propios <strong>middlewares</strong> y pasarlos como lista para
                                personalizar la
                                seguridad y validaciones en cada operación de <code>rest_crud_generate</code>.</p>
                            <p>
                                <strong>
                                    Para generar la documentación recuerda siempre
                                    ejecutar luego de las rutas <code>router.swagger_ui()</code> y
                                    <code>router.openapi_json()</code>
                                </strong>
                            </p>
                            <h5>Parámetros de la función <code>rest_crud_generate</code></h5>
                            <p>A continuación, se detallan los parámetros que acepta esta función para generar el CRUD
                                automáticamente:</p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">core/routing.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
def rest_crud_generate(
self,
connection,
model_sql,
model_pydantic: Type[BaseModel],
select: Optional[List[str]] = None,
columns: Optional[List[str]] = None,
active: bool = False,
delete_logic: bool = False,
middlewares: dict = None,
jsonresponse_prefix:str='',#Retorna siempre con la primer clave 'data' para una lista o diccionario

user_id_session:bool| str=False #Ejemplo para validar en las querys con 'user id' en la clausula where 'user_id'= id session_user (tomado de la sesión)

) :  
                                                     </code></pre>
                                </div>
                            </div>

                            <h5>Documentación automática</h5>
                            <p>A continuación, se muestra un ejemplo de la documentación generada para la función
                                <code>rest_crud_generate</code>:
                            </p>
                            <p>Dirigite a <code>http://127.0.0.1:8001/docs</code>, o como hayas configurado tu .env (por
                                HOST y
                                PORT)</p>
                            <div>
                                <h5>GET - Obtener todos los usuarios</h5>
                                <img src="../img/rest_1.png" alt="GET - Obtener todos los usuarios">
                                <br />

                                <h5>GET -Sálida de todos los usuarios </h5>
                                <img src="../img/rest_2.png" alt="GET - Sálida">
                                <br />

                                <h5>POST - Crear nuevo usuario</h5>
                                <img src="../img/rest_3.png" alt="POST - Crear nuevo usuario">
                                <br />

                                <h5>GET_ID - Obtener un usuario específico</h5>
                                <img src="../img/rest_4-5.png" alt="GET_ID - Obtener un usuario específico">
                                <br />

                                <h5>PUT - Actualizar usuario</h5>
                                <img src="../img/rest_4.png" alt="PUT - Actualizar usuario">
                                <br />

                                <h5>DELETE - Eliminar usuario</h5>
                                <img src="../img/rest_5.png" alt="DELETE - Eliminar usuario">
                                <br />
                            </div>
                            <br />
                            <p>En este ejemplo lo hicimos con 'usuarios' , pero puedes aplicarlo como quieras según tu
                                lógica,
                                'productos','comercios',etc. Hasta modificando el core en <code>core/routing.py</code>
                            </p>

                            <br />
                            <p>
                                <strong>
                                    Tanto para la función por el metodo 'POST' o 'PUT',
                                </strong>
                                Si el framework detecta que pasas datos en el cuerpo de la solicitud como:
                                'password' , los codificará automáticamente con argon2 para hacerlo seguro.
                                Body de ejemplo en la request a enviar :
                            <pre><code class="language-json">
{
"email":"example@example.com",
"name":"name",
"password":"my_password_secret", 
}
                        </code>
                        </pre>
                            </p>
                            <p>Luego, si pasas 'token' o 'hash', con la función del <code>helper</code>
                                <code>generate_token_value</code>
                                , genera automáticamente un token, que se guardará en base como columna 'token'
                                con el valor generado por la función
                                .
                                Body example :
                            <pre><code class="language-json">
{
"email":"example@example.com",
"name":"name",
"password":"my_password_secret",
"token":""
}
                    </code>
                </pre>
                            </p>
                            <p>
                                Con 'created_at' o 'created_date' , guardará la fecha y hora del momento, siempre que
                                ese campo exista en la tabla de la base de datos.
                                Body example :
                            <pre><code class="language-json">
{
"email":"example@example.com",
"name":"name",
"password":"my_password_secret",
"token":"",
"created_at":""
}
                    </code>
                </pre>
                            </p>
                            <p>
                                <strong>Para los metodos 'PUT','GET' (get_id) o 'DELETE'</strong>
                                Es opcional según la logica de cada API REST,le puedes pasar como
                                <code>query string</code> ,
                                <code>user_id</code>
                                o <code>id_user</code>, un ejemplo seria por GET,PUT o DELETE como metodo
                                a la url http://127.0.0.1:8001/api/products/1?user_id=20
                            </p>
                            <p>Donde válida que existe el ID de producto '1' pero también que pertenezca al id de
                                usuario '20' .
                            </p>

                        </article>


                        <article id="admin-panel-esp">
                            <h1>Panel de Administración</h1>
                            <p>
                                El módulo <code>Admin</code> te permite gestionar un panel de administración para tu
                                aplicación.
                                Incluye autenticación, gestión de modelos, métricas del sistema y más. Este panel es
                                altamente personalizable y se integra fácilmente con tu aplicación.
                            </p>
                            <p>
                                El panel de administración ahora es más modular y flexible. Todos los componentes
                                relacionados (plantillas,
                                rutas y configuración) se encuentran en la carpeta <code>admin</code>, lo que facilita
                                su personalización
                                y extensión.
                            </p>

                            <h2>Características Principales</h2>
                            <ul>
                                <li><strong>Autenticación</strong>: Login y logout seguro para administradores.</li>
                                <li><strong>Gestión de Modelos</strong>: Genera automáticamente rutas y vistas para
                                    administrar tus modelos.</li>
                                <li><strong>Métricas del Sistema</strong>: Monitorea el uso de memoria y CPU tanto de la
                                    aplicación como del servidor.</li>
                                <li><strong>Gestión de Contraseñas</strong>: Permite a los administradores cambiar sus
                                    contraseñas.</li>
                                <li><strong>Registros</strong>: Permite a los administradores ver los <code>Logs</code>
                                    de la aplicación.</li>
                            </ul>

                            <h2>Uso Básico</h2>
                            <p>
                                Para usar el panel de administración, debes importar la clase <code>Admin</code> desde
                                <code>admin.routes</code> y pasarle una lista opcional de modelos que quieras
                                administrar.
                                Cada modelo debe implementar un método <code>get_all</code> para mostrarse en el panel.
                            </p>

                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">main.py</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                <code class="language-python">
# English: Here we activate the admin panel with default settings.
# Español: Aquí activamos el panel de administrador con configuraciones predeterminadas.
from app.routes.admin import Admin
from app.models.user import User
admin_routes=Admin(models=[User])
all_routes = list(itertools.chain(routes, api_routes,admin_routes))
                </code>
            </pre>
                                </div>
                            </div>

                            <h2>Configuración y Migraciones</h2>
                            <p>
                                Antes de usar el panel de administración, debes ejecutar las migraciones:
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Terminal</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                <code class="language-bash">
python -m cli.migrations 
                </code>
            </pre>
                                </div>
                            </div>

                            <h2>Creación de Usuarios Admin</h2>
                            <p>
                                Los usuarios administradores se pueden crear mediante línea de comandos con parámetros
                                personalizables:
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Terminal</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                <code class="language-bash">
# Uso por defecto (contraseña aleatoria generada)
python -m cli.create_admin

# Con nombre de usuario y contraseña personalizados
python -m cli.create_admin --user miadmin --password micontraseñasegura
                </code>
            </pre>
                                </div>
                            </div>

                            <h2>Rutas Generadas</h2>
                            <p>
                                El panel de administración genera automáticamente las siguientes rutas:
                            </p>
                            <ul>
                                <li><strong>Login</strong>: <code>/admin/login</code> (GET/POST)</li>
                                <li><strong>Logout</strong>: <code>/admin/logout</code> (GET)</li>
                                <li><strong>Cambiar Contraseña</strong>: <code>/admin/change_password</code> (GET/POST)
                                </li>
                                <li><strong>Dashboard</strong>: <code>/admin</code> (GET)</li>
                                <li><strong>Gestión de Modelos</strong>: <code>/admin/{model_plural}</code> (GET)</li>
                            </ul>

                            <h2>Middleware de Autenticación</h2>
                            <p>
                                Para proteger rutas y asegurar que solo administradores autenticados puedan acceder, usa
                                el
                                decorador <code>@admin_required</code> de <code>core/admin.py</code>.
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Uso del Middleware</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre>
                <code class="language-python">
from lila.core.admin import admin_required

@router.route(path="/admin", methods=["GET"])
@admin_required
async def admin_route(request: Request):
    menu_html = menu(models=models)
    return await admin_dashboard(request=request, menu=menu_html)
                </code>
            </pre>
                                </div>
                            </div>

                            <h2>Métricas del Sistema</h2>
                            <p>
                                El panel de administración muestra métricas en tiempo real, incluyendo:
                            </p>
                            <ul>
                                <li>Uso de memoria del framework Lila.</li>
                                <li>Uso de CPU del framework Lila.</li>
                                <li>Uso de memoria del sistema.</li>
                                <li>Uso de CPU del sistema.</li>
                            </ul>
                            <p>
                                Estas métricas se actualizan cada 10 segundos.
                            </p>

                            <h2>Registros (Logs)</h2>
                            <p>
                                En Lila, usamos un middleware que puedes activar o desactivar si deseas utilizar
                                <code>Logs</code> para información, advertencias o errores en tu aplicación.
                            </p>
                            <p>
                                El middleware se encuentra en <code>core/middleware.py</code> y se añade a la
                                aplicación con:
                                <code>app.add_middleware(ErrorHandlerMiddleware)</code>.
                            </p>
                            <p>
                                Esto ayuda a generar registros que puedes ver en el panel de administración, organizados
                                por fecha
                                (en carpetas) y tipo.
                            </p>
                            <p class="container">
                                <img src="../img/admin.png" alt="admin" />
                            </p>
                            <br />
                            <p class="container">
                                <img src="../img/admin_2.png" alt="admin" />
                            </p>
                        </article>

                        <article id="minify-esp">
                            <h1>Minificar archivos para producción</h1>
                            <p>
                                Con el comando <code>lila-minify</code> puedes minificar tus archivos js,css y html, que
                                esten en las carpetas <code>public</code> y <code>templates</code>
                            </p>


                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Comando de Terminal</span>
                                    <div class="editor-controls">
                                        <div class="control close"></div>
                                        <div class="control minimize"></div>
                                        <div class="control maximize"></div>
                                    </div>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-bash">
lila-minify

#o
python -m cli.minify
                                    </code></pre>
                                </div>
                            </div>
                        </article>


                        <article id="production-esp">
                            <h1>Despliegue a Producción</h1>

                            <h2>Servidor Linux (con systemd)</h2>
                            <p>
                                Para desplegar tu aplicación Lila en un servidor Linux, se recomienda usar un entorno
                                virtual y un servicio de systemd para gestionar el proceso.
                            </p>

                            <h3>1. Crear un Entorno Virtual</h3>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Terminal</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-bash">
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
                                    </code></pre>
                                </div>
                            </div>

                            <h3>2. Crear un Script de Inicio</h3>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">start_lila.sh</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-bash">
#!/bin/bash
source /ruta/a/tu/proyecto/venv/bin/activate
python /ruta/a/tu/proyecto/main.py
                                    </code></pre>
                                </div>
                            </div>

                            <h3>3. Crear un Servicio de systemd</h3>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">/etc/systemd/system/lila.service</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-ini">
[Unit]
Description=Servicio de Lila Framework
After=network.target

[Service]
User=tu_usuario
Group=tu_grupo
WorkingDirectory=/ruta/a/tu/proyecto
ExecStart=/ruta/a/tu/proyecto/start_lila.sh
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
                                    </code></pre>
                                </div>
                            </div>

                            <h3>4. Habilitar e Iniciar el Servicio</h3>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">Terminal</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-bash">
sudo systemctl daemon-reload
sudo systemctl enable lila.service
sudo systemctl start lila.service
                                    </code></pre>
                                </div>
                            </div>

                            <h2>Servidor Windows</h2>
                            <p>
                                En Windows, puedes usar el Programador de Tareas para ejecutar tu aplicación al inicio.
                            </p>
                            <ol>
                                <li>Crea un script `.bat` o `.ps1` para iniciar tu aplicación, similar al script
                                    `start_lila.sh`.</li>
                                <li>Abre el Programador de Tareas.</li>
                                <li>Crea una nueva tarea que se ejecute al inicio del sistema.</li>
                                <li>Establece la acción para que ejecute tu script.</li>
                            </ol>

                            <h2>Desactivar el Modo de Depuración</h2>
                            <p>
                                En tu `main.py`, asegúrate de desactivar el modo de depuración para producción.
                            </p>
                            <div class="code-editor">
                                <div class="editor-header">
                                    <span class="editor-title">main.py</span>
                                </div>
                                <div class="editor-content">
                                    <pre><code class="language-python">
app = App(debug=False, routes=all_routes)
                                    </code></pre>
                                </div>
                            </div>
                        </article>

                        <!-- <article id="helpers-esp">

            </article> -->
                    </div>

                </div>
            </div>

        </div>
    </main>

</body>

</html>